<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fuzzer on Pwn the world.</title>
    <link>https://blog.hexterisk.com/tags/fuzzer/</link>
    <description>Recent content in Fuzzer on Pwn the world.</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>hexterisk@gmail.com (Bhanupratap Singh)</managingEditor>
    <webMaster>hexterisk@gmail.com (Bhanupratap Singh)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 02 Apr 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blog.hexterisk.com/tags/fuzzer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Disassembly and Binary Analysis Fundamentals</title>
      <link>https://blog.hexterisk.com/posts/2020/04/02/disassembly-and-binary-analysis-fundamentals/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://blog.hexterisk.com/posts/2020/04/02/disassembly-and-binary-analysis-fundamentals/</guid>
      <description>&lt;h2 id=&#34;static-disassembly&#34;&gt;Static Disassembly&lt;/h2&gt;&#xA;&lt;p&gt;When people say disassembly, they usually mean static disassembly, which involves extracting the instructions from a binary without executing it.&lt;/p&gt;&#xA;&lt;h3 id=&#34;linear-disassembly&#34;&gt;Linear Disassembly&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../Disassembly_and_Binary_Analysis_Fundamentals/image.png&#34;&gt;&#xA;&lt;em&gt;Disassembly desynchronization due to inline data interpreted as code. The instruction where the disassembly resynchronizes is shaded gray.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;It iterates through all code segments in a binary, decoding all bytes consecutively and parsing them into a list of instructions. Many simple disassemblers, including objdump, use this approach.&lt;/li&gt;&#xA;&lt;li&gt;The risk is that not all bytes may be instructions.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Some compilers like Visual Studio intersperse data such as jump tables with the code, without leaving any clues as to where exactly that data is. If disassemblers accidentally parse this inline data as code, they may encounter invalid opcodes. Even worse, the data bytes may coincidentally correspond to valid opcodes, leading the disassembler to output bogus instructions. This is especially likely on dense ISAs like x86, where most byte values represent a valid opcode.&lt;/li&gt;&#xA;&lt;li&gt;On ISAs with variable-length opcodes such as x86, inline data may even cause the disassembler to become desynchronized with respect to the true instruction stream. Though the disassembler will typically self-resynchronize, desynchronization can cause the first few real instructions following inline data to be missed.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;recursive-disassembly&#34;&gt;Recursive Disassembly&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Sensitive to control flow, it starts from known entry points into the binary (such as the main entry point and exported function symbols) and from there recursively follows control flow (such as jumps and calls) to discover code. This allows recursive disassembly to work around data bytes in all but a handful of corner cases.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;To maximize code coverage, recursive disassemblers typically assume that the bytes directly after a call instruction must also be disassembled since they are the most likely target of an eventual ret. Additionally, disassemblers assume that both edges of a conditional jump target valid instructions. Both of these assumptions may be violated in rare cases, such as in deliberately obfuscated binaries.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;The downside of this approach is that not all control flow is so easy to follow. For instance, it’s often difficult, if not impossible, to statically figure out the possible targets of indirect jumps or calls. As a result, the disassembler may miss blocks of code, or even entire functions, targeted by indirect jumps or calls, unless it uses special heuristics to resolve the control flow. For example, jump tables make recursive disassembly more difficult because they use &lt;strong&gt;indirect control flow&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt; &lt;/p&gt;</description>
    </item>
  </channel>
</rss>
