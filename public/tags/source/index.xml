<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Source on Pwn the world.</title>
    <link>https://hexterisk.com/blog/tags/source/</link>
    <description>Recent content in Source on Pwn the world.</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>hexterisk@gmail.com (Bhanupratap Singh)</managingEditor>
    <webMaster>hexterisk@gmail.com (Bhanupratap Singh)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 28 Sep 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://hexterisk.com/blog/tags/source/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Source Code Instrumentation and LLVM</title>
      <link>https://hexterisk.com/blog/posts/2020/09/28/source-code-instrumentation-and-llvm/</link>
      <pubDate>Mon, 28 Sep 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://hexterisk.com/blog/posts/2020/09/28/source-code-instrumentation-and-llvm/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Source Code Instrumentation&lt;/strong&gt; adds specific code meant for instrumentation/analysis, called &lt;strong&gt;Instrumentation Code&lt;/strong&gt;, to the source files of the program under consideration. The source files are then compiled and executed. Since the instrumentation code is integrated into the binary itself, the output from the execution includes the dump of the instrumentation code which can then be used for further analysis and component testing.&lt;/p&gt;&#xA;&lt;p&gt;Â &lt;/p&gt;&#xA;&lt;h2 id=&#34;intermediate-representations&#34;&gt;Intermediate Representations&lt;/h2&gt;&#xA;&lt;p&gt;Representation of a program in a state that lies between the source code and the compiled binary(specifically, the assembly code). Compilers have a stage of intermediate code generation, where they natively generate IR of the source code.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Taint Analysis</title>
      <link>https://hexterisk.com/blog/posts/2020/07/17/taint-analysis/</link>
      <pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://hexterisk.com/blog/posts/2020/07/17/taint-analysis/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Taint Analysis&lt;/strong&gt; is a program analysis technique that allows you to determine the influence that a selected program state has on other parts of the program state. Taint any data that a program receives from the network, track that data, and raise an alert if it affects the program counter. If an operation uses the value of some tainted object, say &lt;em&gt;X&lt;/em&gt;, to derive a value for another, say &lt;em&gt;Y&lt;/em&gt;, then object &lt;em&gt;Y&lt;/em&gt; becomes tainted. Object &lt;em&gt;X&lt;/em&gt; tainted the object &lt;em&gt;Y&lt;/em&gt;. Taint Analysis can be classified into two types.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
