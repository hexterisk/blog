<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Matasano on Pwn the world.</title>
    <link>https://blogs.hexterisk.com/tags/matasano/</link>
    <description>Recent content in Matasano on Pwn the world.</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>hexterisk@gmail.com (Bhanupratap Singh)</managingEditor>
    <webMaster>hexterisk@gmail.com (Bhanupratap Singh)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 01 Jun 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blogs.hexterisk.com/tags/matasano/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Set 6</title>
      <link>https://blogs.hexterisk.com/posts/2020/06/01/set-6/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://blogs.hexterisk.com/posts/2020/06/01/set-6/</guid>
      <description>&lt;p&gt;Refer to this &lt;a href=&#34;https://github.com/hexterisk/cryptopals-solutions&#34;&gt;repository&lt;/a&gt; for solution scripts and the IPython Notebook pertaining to the explanations here.&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h3 id=&#34;challenge-41-implement-unpadded-message-recovery-oracle&#34;&gt;Challenge 41: Implement unpadded message recovery oracle&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cryptopals.com/sets/6/challenges/41&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Nate Lawson says we should stop calling it &amp;ldquo;RSA padding&amp;rdquo; and start calling it &amp;ldquo;RSA armoring&amp;rdquo;. Here&amp;rsquo;s why.&lt;br&gt;&#xA;Imagine a web application, again with the Javascript encryption, taking RSA-encrypted messages which (again: Javascript) aren&amp;rsquo;t padded before encryption at all.&lt;br&gt;&#xA;You can submit an arbitrary RSA blob and the server will return plaintext. But you can&amp;rsquo;t submit the same message twice: let&amp;rsquo;s say the server keeps hashes of previous messages for some liveness interval, and that the message has an embedded timestamp: ** {&lt;br&gt;&#xA;time: 1356304276,&lt;br&gt;&#xA;social: &amp;lsquo;555-55-5555&amp;rsquo;,&lt;br&gt;&#xA;}&lt;br&gt;&#xA;You&amp;rsquo;d like to capture other people&amp;rsquo;s messages and use the server to decrypt them. But when you try, the server takes the hash of the ciphertext and uses it to reject the request. Any bit you flip in the ciphertext irrevocably scrambles the decryption.&lt;br&gt;&#xA;This turns out to be trivially breakable:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Set 5</title>
      <link>https://blogs.hexterisk.com/posts/2020/05/17/set-5/</link>
      <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://blogs.hexterisk.com/posts/2020/05/17/set-5/</guid>
      <description>&lt;p&gt;Refer to this &lt;a href=&#34;https://github.com/hexterisk/cryptopals-solutions&#34;&gt;repository&lt;/a&gt; for solution scripts and the IPython Notebook pertaining to the explanations here.&lt;/p&gt;&#xA;&lt;h3 id=&#34;challenge-33-implement-diffie-hellman&#34;&gt;Challenge 33: Implement Diffie-Hellman&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cryptopals.com/sets/4/challenges/33&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;For one of the most important algorithms in cryptography this exercise couldn&amp;rsquo;t be a whole lot easier.&lt;br&gt;&#xA;Set a variable &amp;ldquo;p&amp;rdquo; to 37 and &amp;ldquo;g&amp;rdquo; to 5. This algorithm is so easy I&amp;rsquo;m not even going to explain it. Just do what I do.&lt;br&gt;&#xA;Generate &amp;ldquo;a&amp;rdquo;, a random number mod 37. Now generate &amp;ldquo;A&amp;rdquo;, which is &amp;ldquo;g&amp;rdquo; raised to the &amp;ldquo;a&amp;rdquo; power mode 37 &amp;mdash; A = (g**a) % p.&lt;br&gt;&#xA;Do the same for &amp;ldquo;b&amp;rdquo; and &amp;ldquo;B&amp;rdquo;.&lt;br&gt;&#xA;&amp;ldquo;A&amp;rdquo; and &amp;ldquo;B&amp;rdquo; are public keys. Generate a session key with them; set &amp;ldquo;s&amp;rdquo; to &amp;ldquo;B&amp;rdquo; raised to the &amp;ldquo;a&amp;rdquo; power mod 37 &amp;mdash; s = (B**a) % p.&lt;br&gt;&#xA;Do the same with A**b, check that you come up with the same &amp;ldquo;s&amp;rdquo;.&lt;br&gt;&#xA;To turn &amp;ldquo;s&amp;rdquo; into a key, you can just hash it to create 128 bits of key material (or SHA256 it to create a key for encrypting and a key for a MAC).&lt;br&gt;&#xA;Ok, that was fun, now repeat the exercise with bignums like in the real world. Here are parameters NIST likes:&lt;br&gt;&#xA;&lt;strong&gt;p:&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;bb9ed529077096966d670c354e4abc9804f1746c08ca237327fff&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;fffffffffffff&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;g: 2&lt;/strong&gt;&lt;br&gt;&#xA;This is very easy to do in Python or Ruby or other high-level languages that auto-promote fixnums to bignums, but it isn&amp;rsquo;t &amp;ldquo;hard&amp;rdquo; anywhere.&lt;br&gt;&#xA;Note that you&amp;rsquo;ll need to write your own modexp (this is blackboard math, don&amp;rsquo;t freak out), because you&amp;rsquo;ll blow out your bignum library raising &amp;ldquo;a&amp;rdquo; to the 1024-bit-numberth power. You can find modexp routines on Rosetta Code for most languages.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Set 4</title>
      <link>https://blogs.hexterisk.com/posts/2020/05/06/set-4/</link>
      <pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://blogs.hexterisk.com/posts/2020/05/06/set-4/</guid>
      <description>&lt;p&gt;Refer to this &lt;a href=&#34;https://github.com/hexterisk/cryptopals-solutions&#34;&gt;repository&lt;/a&gt; for solution scripts and the IPython Notebook pertaining to the explanations here.&lt;/p&gt;&#xA;&lt;h3 id=&#34;challenge-25-break-random-access-readwrite-aes-ctr&#34;&gt;Challenge 25: Break &amp;ldquo;random access read/write&amp;rdquo; AES CTR&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cryptopals.com/sets/4/challenges/25&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Back to CTR. Encrypt the recovered plaintext from &lt;a href=&#34;https://cryptopals.com/static/challenge-data/25.txt&#34;&gt;this file&lt;/a&gt; (the ECB exercise) under CTR with a random key (for this exercise the key should be unknown to you, but hold on to it).&lt;/p&gt;&#xA;&lt;p&gt;Now, write the code that allows you to &amp;ldquo;seek&amp;rdquo; into the ciphertext, decrypt, and re-encrypt with different plaintext. Expose this as a function, like, &lt;em&gt;&amp;ldquo;edit(ciphertext, key, offset, newtext)&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Set 3</title>
      <link>https://blogs.hexterisk.com/posts/2020/04/29/set-3/</link>
      <pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://blogs.hexterisk.com/posts/2020/04/29/set-3/</guid>
      <description>&lt;p&gt;Refer to this &lt;a href=&#34;https://github.com/hexterisk/cryptopals-solutions&#34;&gt;repository&lt;/a&gt; for solution scripts and the IPython Notebook pertaining to the explanations here.&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h3 id=&#34;challenge-17-the-cbc-padding-oracle&#34;&gt;Challenge 17: The CBC padding oracle&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cryptopals.com/sets/3/challenges/17&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This is the best-known attack on modern block-cipher cryptography.&lt;br&gt;&#xA;Combine your padding code and your CBC code to write two functions.&lt;br&gt;&#xA;The first function should select at random one of the following 10 strings:&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=&lt;/strong&gt;&lt;br&gt;&#xA;&lt;strong&gt;MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93&lt;/strong&gt;&lt;br&gt;&#xA;&amp;hellip; generate a random AES key (which it should save for all future encryptions), pad the string out to the 16-byte AES block size and CBC-encrypt it under that key, providing the caller the ciphertext and IV.&lt;br&gt;&#xA;The second function should consume the ciphertext produced by the first function, decrypt it, check its padding, and return true or false depending on whether the padding is valid.&lt;br&gt;&#xA;It turns out that it&amp;rsquo;s possible to decrypt the ciphertexts provided by the first function.&lt;br&gt;&#xA;The decryption here depends on a side-channel leak by the decryption function. The leak is the error message that the padding is valid or not.&lt;br&gt;&#xA;You can find 100 web pages on how this attack works, so I won&amp;rsquo;t re-explain it. What I&amp;rsquo;ll say is this:&lt;br&gt;&#xA;The fundamental insight behind this attack is that the byte 01h is valid padding, and occur in 1/256 trials of &amp;ldquo;randomized&amp;rdquo; plaintexts produced by decrypting a tampered ciphertext.&lt;br&gt;&#xA;02h in isolation is not valid padding.&lt;br&gt;&#xA;02h 02h is valid padding, but is much less likely to occur randomly than 01h.&lt;br&gt;&#xA;03h 03h 03h is even less likely.&lt;br&gt;&#xA;So you can assume that if you corrupt a decryption AND it had valid padding, you know what that padding byte is.&lt;br&gt;&#xA;It is easy to get tripped up on the fact that CBC plaintexts are &amp;ldquo;padded&amp;rdquo;. Padding oracles have nothing to do with the actual padding on a CBC plaintext. It&amp;rsquo;s an attack that targets a specific bit of code that handles decryption. You can mount a padding oracle on any CBC block, whether it&amp;rsquo;s padded or not.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Set 2</title>
      <link>https://blogs.hexterisk.com/posts/2020/04/24/set-2/</link>
      <pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://blogs.hexterisk.com/posts/2020/04/24/set-2/</guid>
      <description>&lt;p&gt;Refer to this &lt;a href=&#34;https://github.com/hexterisk/cryptopals-solutions&#34;&gt;repository&lt;/a&gt; for solution scripts and the IPython Notebook pertaining to the explanations here.&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h3 id=&#34;challenge-9-implement-pkcs7-padding&#34;&gt;Challenge 9: Implement PKCS#7 padding&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cryptopals.com/sets/2/challenges/9&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;A block cipher transforms a fixed-sized block (usually 8 or 16 bytes) of plaintext into ciphertext. But we almost never want to transform a single block; we encrypt irregularly-sized messages.&lt;br&gt;&#xA;One way we account for irregularly-sized messages is by padding, creating a plaintext that is an even multiple of the blocksize. The most popular padding scheme is called PKCS#7.&lt;br&gt;&#xA;So: pad any block to a specific block length, by appending the number of bytes of padding to the end of the block. For instance,&lt;br&gt;&#xA;&lt;strong&gt;&amp;ldquo;YELLOW SUBMARINE&amp;rdquo;&lt;/strong&gt;&lt;br&gt;&#xA;&amp;hellip; padded to 20 bytes would be:&lt;br&gt;&#xA;&lt;strong&gt;&amp;ldquo;YELLOW SUBMARINE\x04\x04\x04\x04&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Set 1</title>
      <link>https://blogs.hexterisk.com/posts/2020/04/20/set-1/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://blogs.hexterisk.com/posts/2020/04/20/set-1/</guid>
      <description>&lt;p&gt;Refer to this &lt;a href=&#34;https://github.com/hexterisk/cryptopals-solutions&#34;&gt;repository&lt;/a&gt; for solution scripts and the IPython Notebook pertaining to the explanations here.&lt;/p&gt;&#xA;&lt;h3 id=&#34;challenge-1-convert-hex-to-base64&#34;&gt;Challenge 1: Convert hex to base64&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cryptopals.com/sets/1/challenges/1&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The string:&lt;br&gt;&#xA;&lt;strong&gt;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f697&lt;/strong&gt;  &lt;strong&gt;36f6e6f7573206d757368726f6f6d&lt;/strong&gt;&lt;br&gt;&#xA;Should produce:&lt;br&gt;&#xA;&lt;strong&gt;SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t&lt;/strong&gt;&lt;br&gt;&#xA;So go ahead and make that happen.&lt;br&gt;&#xA;You&amp;rsquo;ll need to use this code for the rest of the exercises.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Data, essentially raw bytes/binary (0, 1), can be represented in various forms and formats as required. These representations may be used for simply the presentation of data, or may be required by some protocol so as to prevent misinterpretation of data.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
