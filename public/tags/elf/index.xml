<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elf on Pwn the world.</title>
    <link>https://blogs.hexterisk.com/tags/elf/</link>
    <description>Recent content in Elf on Pwn the world.</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>hexterisk@gmail.com (Bhanupratap Singh)</managingEditor>
    <webMaster>hexterisk@gmail.com (Bhanupratap Singh)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 15 Mar 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blogs.hexterisk.com/tags/elf/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Simple Code Injection Techniques for ELF</title>
      <link>https://blogs.hexterisk.com/posts/2020/03/15/simple-code-injection-techniques-for-elf/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://blogs.hexterisk.com/posts/2020/03/15/simple-code-injection-techniques-for-elf/</guid>
      <description>&lt;h2 id=&#34;bare-metal-binary-modification&#34;&gt;Bare-Metal Binary Modification&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Modify an existing binary is by directly editing the bytes of a binary file in hexadecimal format, using a program like &lt;em&gt;hexedit&lt;/em&gt;.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Use a disassembler to identify the code or data bytes to be changed and then use a hex editor to make the changes.&lt;/li&gt;&#xA;&lt;li&gt;Advantage: Simple and requires only basic tools. Any padding bytes, dead code (such as unused functions), or unused data, can be overwritten with something new.&lt;/li&gt;&#xA;&lt;li&gt;Disadvantage: Only allows in-place editing. Can change code or data bytes but not add anything new. Inserting a new byte causes all the bytes after it to shift to another address, which breaks references to the shifted bytes. It’s difficult (or even impossible) to correctly identify and fix all the broken references, because the relocation information needed for this is usually discarded after the linking phase.&lt;/li&gt;&#xA;&lt;li&gt;Works for cases like replacing malware&amp;rsquo;s anti-debugging checks with nop.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Off-by-one&lt;/strong&gt; bugs typically occur in loops when the programmer uses an erroneous loop condition that causes the loop to read or write one too few or one too many bytes.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>The ELF Format</title>
      <link>https://blogs.hexterisk.com/posts/2020/03/07/the-elf-format/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><author>hexterisk@gmail.com (Bhanupratap Singh)</author>
      <guid>https://blogs.hexterisk.com/posts/2020/03/07/the-elf-format/</guid>
      <description>&lt;p&gt;ELF binaries really consist of only four types of components: &lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Executable Header&lt;/li&gt;&#xA;&lt;li&gt;Program Headers (optional)&lt;/li&gt;&#xA;&lt;li&gt;Sections&lt;/li&gt;&#xA;&lt;li&gt;Section Headers, one per section (optional)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../The_ELF_Format/1_image.png&#34;&gt;&#xA;&lt;em&gt;64-bit ELF binary structure.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;executable-header&#34;&gt;Executable Header&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Every ELF file starts with an executable header, which is just a structured series of bytes telling you that it’s an ELF file and other metadata.&lt;/li&gt;&#xA;&lt;li&gt;Format of executable header: /usr/include/elf.h&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; e_ident[&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;/* Magic number and other info */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; e_type; &lt;span style=&#34;color:#75715e&#34;&gt;/* Object file type */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; e_machine; &lt;span style=&#34;color:#75715e&#34;&gt;/* Architecture */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; e_version; &lt;span style=&#34;color:#75715e&#34;&gt;/* Object file version */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; e_entry; &lt;span style=&#34;color:#75715e&#34;&gt;/* Entry point virtual address */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; e_phoff; &lt;span style=&#34;color:#75715e&#34;&gt;/* Program header table file offset */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; e_shoff; &lt;span style=&#34;color:#75715e&#34;&gt;/* Section header table file offset */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; e_flags; &lt;span style=&#34;color:#75715e&#34;&gt;/* Processor-specific flags */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; e_ehsize; &lt;span style=&#34;color:#75715e&#34;&gt;/* ELF header size in bytes */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; e_phentsize; &lt;span style=&#34;color:#75715e&#34;&gt;/* Program header table entry size */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; e_phnum; &lt;span style=&#34;color:#75715e&#34;&gt;/* Program header table entry count */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; e_shentsize; &lt;span style=&#34;color:#75715e&#34;&gt;/* Section header table entry size */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; e_shnum; &lt;span style=&#34;color:#75715e&#34;&gt;/* Section header table entry count */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; e_shstrndx; &lt;span style=&#34;color:#75715e&#34;&gt;/* Section header string table index */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} Elf64_Ehdr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
  </channel>
</rss>
