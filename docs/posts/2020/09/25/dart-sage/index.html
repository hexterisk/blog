<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="map[name:hexterisk]">
<meta name="description" content="Back in 2005, researchers at Microsoft came up with a concolic testing tool called DART(Directed Automated Random Testing). The tool can be used in the unit testing phase, as well as can be applied to large programs.
 We present a new tool, named DART, for automatically testing software that combines three main techniques: (1) automated extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs random testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test inputs to direct systematically the execution along alternative program paths." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="https://hexterisk.github.io/blog/posts/2020/09/25/dart-sage/" />


    <title>
        
            DART &amp; SAGE: Pwn the world.  — A noob&#39;s attempt at blogging.
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://hexterisk.github.io/blog/main.min.bc21949b46a7b314448099a92fed1807acac025093285f474b88259eec0c62ba.css">




    <link rel="apple-touch-icon" sizes="180x180" href="https://hexterisk.github.io/blog/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://hexterisk.github.io/blog/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://hexterisk.github.io/blog/favicon-16x16.png">
    <link rel="manifest" href="https://hexterisk.github.io/blog/site.webmanifest">
    <link rel="mask-icon" href="https://hexterisk.github.io/blog/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="https://hexterisk.github.io/blog/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">

<meta itemprop="name" content="DART &amp; SAGE">
<meta itemprop="description" content="Back in 2005, researchers at Microsoft came up with a concolic testing tool called DART(Directed Automated Random Testing). The tool can be used in the unit testing phase, as well as can be applied to large programs.
 We present a new tool, named DART, for automatically testing software that combines three main techniques: (1) automated extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs random testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test inputs to direct systematically the execution along alternative program paths."><meta itemprop="datePublished" content="2020-09-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-09-25T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2524"><meta itemprop="image" content="https://hexterisk.github.io/blog"/>
<meta itemprop="keywords" content="fuzzing,microsoft,whitebox,greybox,sage,dart,automated,symbolic," /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://hexterisk.github.io/blog"/>

<meta name="twitter:title" content="DART &amp; SAGE"/>
<meta name="twitter:description" content="Back in 2005, researchers at Microsoft came up with a concolic testing tool called DART(Directed Automated Random Testing). The tool can be used in the unit testing phase, as well as can be applied to large programs.
 We present a new tool, named DART, for automatically testing software that combines three main techniques: (1) automated extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs random testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test inputs to direct systematically the execution along alternative program paths."/>



    <meta property="article:section" content="art-of-fuzzing" />



    <meta property="article:published_time" content="2020-09-25 00:00:00 &#43;0000 UTC" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://hexterisk.github.io/blog/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$cd ~/</span>
            <span class="logo__cursor" style=""></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://hexterisk.github.io/blog/about/">About</a></li><li><a href="https://hexterisk.github.io/blog/posts/">Posts</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
<main class="post">

    <div class="post-info">
        <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                class="feather feather-clock">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>12 minutes

            

        </p>
    </div>

    <article>
        <h1 class="post-title">
            <a href="https://hexterisk.github.io/blog/posts/2020/09/25/dart-sage/">DART &amp; SAGE</a>
        </h1>

        

        <div class="post-content">
            <p>Back in 2005, researchers at Microsoft came up with a concolic testing tool called <strong>DART</strong>(<strong>Directed Automated Random Testing</strong>). The tool can be used in the unit testing phase, as well as can be applied to large programs.</p>
<blockquote>
<p>We present a new tool, named DART, for automatically testing software that combines three main techniques: (1) automated extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs random testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test inputs to direct systematically the execution along alternative program paths.</p>
</blockquote>
<p>Breaking down the three techniques mentioned:</p>
<p>For given functions <em>f</em> and <em>h</em>,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span> (<span style="color:#66d9ef">int</span> x) { 
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> x;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">h</span> (<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
	<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">!=</span> y)
		<span style="color:#66d9ef">if</span> (f(x) <span style="color:#f92672">==</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>) <span style="color:#960050;background-color:#1e0010">➊</span>
			abort(); <span style="color:#75715e">/* error */</span>
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ol>
<li>Automated interface extraction:
<ul>
<li>The static source code is parsed to find the program&rsquo;s interfaces.
<ul>
<li>Inputs - arguments given to the main function, variables with environment dependent values and external function calls, any database fetch for data.</li>
<li>Outputs - any data sent to the console.</li>
</ul>
</li>
<li>In the example, static parsing would show that the function takes two integer arguments as input, namely, <em>x</em> and <em>y</em>.</li>
</ul>
</li>
<li>Automatic generation of a test driver for random testing through the interface:
<ul>
<li>Once the interfaces have been determined, a test driver can be generated to simulate the testing of the program in the most general environment that the program is meant to operate in.</li>
<li>The framework attempts the exploration of all execution paths by randomly initializing all local and external variables, and simulates all the external functions.</li>
<li>In the example, the variables will initially be assigned random values, say <em>x = 5</em>. On reaching ➊, a condition is encountered and branches are discovered. The path constraint is evaluated to be <em>(2 * x) == (x + 10)</em>.</li>
</ul>
</li>
<li>Dynamic test generation to direct execution along alternative program paths:
<ul>
<li>Execution is started with a random input, and then the inputs for the next execution are calculated by a solving the symbolic constraints encountered in the current execution.</li>
<li>This allows DART to perform a <strong>directed search</strong>, as the new input vector shall “direct” the execution of the program through a new path to cover newer regions of the binary.</li>
<li>This process is looped till full coverage of the binary is achieved or a bug is encountered.</li>
<li>In the example, a constraint solver will solve the condition encountered to find the values, <em>x = 10</em> here, will move the program forward towards the unexplored branches, and provide that as the input vector in the next execution to explore that particular branch.</li>
</ul>
</li>
</ol>
<p>Therefore, DART eliminates the requirement of writing a test driver and a corresponding harness for testing of the given program. It detects the output during all test cases and checks for standard errors such as violations and crashes.</p>
<p><img src="https://hexterisk.github.io/blog/DART_&amp;_SAGE/image.png" alt="">
<em>DART overview.</em></p>
<h3 id="execution-model">Execution Model</h3>
<p>DART executes a program <em>P</em> both concretely and symbolically, in parallel. The concrete execution is given concrete values as input, decided by the symbolic execution, which allows it to collect various path constraints that are solved to generate inputs for the next test case. </p>
<p>A <strong>transition system</strong> is required to maintain this side-by-side execution, which is basically a state machine. This represents(tracks) values of all variables and program counter, and a transition denotes the execution of a program statement(machine level instructions) that results in the change of state. Therefore, each execution would result in a path through this transition system. These semantics require assistance of RAM to keep track of such program statements.</p>
<p>This parallel execution can be summarized as:</p>
<p>The program P defines a sequence of input addresses for the input parameters. A randomly initialized vector associates a value to each input parameter, thus defining the initial value for the set of these input addresses, defined as state <em>M</em>.</p>
<p>Let <em>C</em> be the set of conditional statements encountered in <em>P</em>.</p>
<p>Let <em>A</em> be the set of assignment statements encountered in <em>P</em>.</p>
<p>Then, execution of a program statement can be denoted as follows:</p>
<p><em>M' := M + [ m → v ]</em></p>
<p>where,</p>
<p>       <em>M</em> is the mapping of a memory address space beginning from \(m\) to \(n\)-bit words (\(n\) can be taken as 32).</p>
<p>       <em>+</em> denotes updation.</p>
<p>       <em>→</em> denotes assignment.</p>
<p>       <em>m</em> is a memory address, which may or may not be holding a symbolic variable.</p>
<p>       <em>M'</em> is therefore same as <em>M</em>, except that <em>m</em> is updated to the value <em>v</em>.</p>
<p>⇨ <em>M' = v</em></p>
<p>Thus, <em>M</em> and <em>M'</em> are the states (also called context), and the updated value <em>v</em> is the solution for the constraint and will be used as input in the next execution.</p>
<p>This program execution <em>E</em> is a finite sequence which goes on until an abort is encountered (such as a program crash) or a halt is encountered (such as program termination). This execution process can be denoted as follows:</p>
<p><em>E := (A ⋃ C) * (abort | halt)</em></p>
<p>This <em>E(P)</em> can be viewed as a tree, known as <strong>execution tree</strong>, where different paths branching from the current state are children of the current node, with leaf nodes being the abort and halt states. Each execution sequence is therefore a path in this tree.</p>
<h3 id="symbolic-evaluation-model">Symbolic Evaluation Model</h3>
<p>DART maintains a symbolic memory map <em>S</em> that maps memory address to symbolic expressions. During the execution process, DART constantly evaluates the path constraints encountered to generate new input vector for the subsequent executions. Only linear path constraints are supported. Any non-linear constraint is ignored and concrete values are used instead of symbolic values.</p>
<p>During the initiation of execution of <em>P</em>, <em>S</em> records the mapping of random values to input parameters. The following algorithms takes an expression <em>e</em> in a context <em>M</em> with already available expression set <em>S</em> and is evaluated as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">evaluate_symbolic (e, M, S)<span style="color:#f92672">:</span>
	
	<span style="color:#75715e">// Switch case to match expression.
</span><span style="color:#75715e"></span>	match e:
		
		<span style="color:#75715e">// Case is only a symbolic variable.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> m:
			
			<span style="color:#75715e">// Directly assign it to the symbolic expression set.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> m <span style="color:#960050;background-color:#1e0010">∈</span> domain S then <span style="color:#66d9ef">return</span> S(m)
			
			<span style="color:#75715e">// Return the updated memory.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> M(m)
		
		<span style="color:#75715e">// Case is any arithmetic operation (multiplication in this case).
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> <span style="color:#960050;background-color:#1e0010">∗</span>(e<span style="color:#960050;background-color:#1e0010">&#39;</span>, e<span style="color:#960050;background-color:#1e0010">&#39;&#39;</span>)<span style="color:#f92672">:</span>
			
			<span style="color:#75715e">// Evaluate the symbolic expressions individually first.
</span><span style="color:#75715e"></span>			let f<span style="color:#960050;background-color:#1e0010">’</span> <span style="color:#f92672">=</span> evaluate_symbolic(e<span style="color:#960050;background-color:#1e0010">&#39;</span>, M, S);
			let f<span style="color:#960050;background-color:#1e0010">”</span> <span style="color:#f92672">=</span> evaluate_symbolic(e<span style="color:#960050;background-color:#1e0010">&#39;&#39;</span>, M, S);
			
			<span style="color:#75715e">// If none of the evaluated results are constants, then the constraint becomes non-linear.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> not one of f<span style="color:#960050;background-color:#1e0010">&#39;</span> or f<span style="color:#960050;background-color:#1e0010">&#39;&#39;</span> is a constant c then
				
				<span style="color:#75715e">// Since DART doesn&#39;t work with non-linear constraints, unset linearity flag.
</span><span style="color:#75715e"></span>				<span style="color:#960050;background-color:#1e0010">➋</span> all_linear <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
				<span style="color:#75715e">// Simply performs concrete evaluation and update the memory, it doesn&#39;t store the constraint.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">return</span> evaluate_concrete(e, M)
			
			<span style="color:#75715e">// No expression to evaluate so simply performs concrete evaluation.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> both f<span style="color:#960050;background-color:#1e0010">&#39;</span> and f<span style="color:#960050;background-color:#1e0010">&#39;&#39;</span> are constants then
				<span style="color:#66d9ef">return</span> evaluate_concrete(e, M)
			
			<span style="color:#75715e">// If either one is a constant, it&#39;ll evaluate the expression and return.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> f<span style="color:#960050;background-color:#1e0010">&#39;</span> is a constant c then
				<span style="color:#66d9ef">return</span> <span style="color:#960050;background-color:#1e0010">∗</span>(f<span style="color:#960050;background-color:#1e0010">&#39;</span> , c)
			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#960050;background-color:#1e0010">∗</span>(c, f<span style="color:#960050;background-color:#1e0010">&#39;&#39;</span>)
		
		<span style="color:#75715e">// Case is pointer dereference.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> <span style="color:#960050;background-color:#1e0010">∗</span>e<span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#f92672">:</span>
			
			<span style="color:#75715e">// Symbolically evaluate the expression at the address first.
</span><span style="color:#75715e"></span>			let f<span style="color:#960050;background-color:#1e0010">’</span><span style="color:#f92672">=</span> evaluate_symbolic(e<span style="color:#960050;background-color:#1e0010">&#39;</span> ,M, S);
			
			<span style="color:#75715e">// If the result is constant
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> f<span style="color:#960050;background-color:#1e0010">&#39;</span> is a constant c then
			
				<span style="color:#75715e">// The expression it is pointing to belongs to the set of expressions, return itself.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> <span style="color:#960050;background-color:#1e0010">∗</span>c <span style="color:#960050;background-color:#1e0010">∈</span> domain S then <span style="color:#66d9ef">return</span> S <span style="color:#960050;background-color:#1e0010">∗</span> c
				
				<span style="color:#75715e">// Return pointer to the memory location.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> M(<span style="color:#960050;background-color:#1e0010">∗</span>c)
			
			<span style="color:#75715e">// If it cannot determine either of the aforementioned cases, set all memory locations are not definitely known.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">else</span> <span style="color:#960050;background-color:#1e0010">➌</span> all_locs_definite <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
			
				<span style="color:#75715e">// Simply performs concrete evaluation and update the memory.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">return</span> evaluate concrete(e, M)
</code></pre></div><p>It&rsquo;s possible for DART to not know all the memory locations definitely (➌) because it doesn&rsquo;t always evaluate all the symbolic expressions (➋).</p>
<h3 id="test-driver">Test Driver</h3>
<p>The primary task of the test driver is to combine random testing with directed search. Any exception encountered during this process indicates a bug.</p>
<p>Two completeness flags work in conjunction to indicate cases when symbolic execution is not performed:</p>
<ol>
<li><strong>all_linear</strong>: set to 0 when symbolic expression becomes non-linear (➋).</li>
<li><strong>all_locs_definite</strong>: set to 0 when value of a symbolic variable is unknown (➌).</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">run <span style="color:#a6e22e">DART</span> () <span style="color:#f92672">=</span>

	<span style="color:#75715e">// Initialise all flags to 1.
</span><span style="color:#75715e"></span>	all linear, all locs definite, forcing ok <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>
	
	<span style="color:#75715e">// Random testing loop.
</span><span style="color:#75715e"></span>	repeat
	
		<span style="color:#75715e">// Initialise stack to empty, input vector to empty and set directed search to true.
</span><span style="color:#75715e"></span>		stack <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;&gt;</span>; I <span style="color:#f92672">=</span> [] ; directed <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
		
		<span style="color:#75715e">// Perform directed search.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> (directed) <span style="color:#66d9ef">do</span>
		
			<span style="color:#75715e">// Run instrumented program.
</span><span style="color:#75715e"></span>			try (directed, stack, I) <span style="color:#f92672">=</span>
				instrumented program(stack, I)
				
			<span style="color:#75715e">// Any exception encoutered implies a bug has been found.
</span><span style="color:#75715e"></span>			catch any exception <span style="color:#960050;background-color:#1e0010">→</span>
				<span style="color:#66d9ef">if</span> (forcing ok)
					print <span style="color:#960050;background-color:#1e0010">“</span>Bug found<span style="color:#960050;background-color:#1e0010">”</span>
					exit()
				
				<span style="color:#75715e">// Forces exit in the next iteration if a bug has been found.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">else</span> forcing ok <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
		
	<span style="color:#75715e">// Exit testing if any completeness flags is set to 0.
</span><span style="color:#75715e"></span>	until all_linear <span style="color:#960050;background-color:#1e0010">∧</span> all_locs_definite
</code></pre></div><p>Once the directed search ends, and if the completeness flags still hold true(both set to 1), then the outer loop exits. DART has then said to have explored all feasible program paths. However, any one of the completeness flags set to 0 during the testing process indicates a bad situation. And if any one of them get&rsquo;s turned off during execution, the random testing process will continue till manually stopped.</p>
<p>Each run of the instrumented program is executed with the results of the conditional statements in the previous execution (except the first run, it is with random values). And for each conditional statement, we note:</p>
<ol>
<li><strong>branch</strong> value: set to 1 when the <code>then</code> branch is taken, 0 otherwise.</li>
<li><strong>done</strong> value: set to 0 only when one branch of conditional has executed in the prior runs, 1 otherwise.</li>
</ol>
<p>This information associated with each conditional statement of the last execution path is stored in the <em>stack</em>.</p>
<p>Therefore, <em>for i ∈ 0 ≤ i ≤ |stack|</em>, <em>stack[i] = (stack[i].branch, stack[i].done)</em> is the record corresponding to the (i + 1_) conditional statement.</p>
<p>The program is instrumented as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">instrumented <span style="color:#a6e22e">program</span>(stack, I) <span style="color:#f92672">=</span>

	<span style="color:#75715e">// Random initialization of uninitialized input parameters in M0.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> each input x with I[x] undefined <span style="color:#66d9ef">do</span>
			I[x] <span style="color:#f92672">=</span> random()
	
	Initialize memory M from M0 and I.

	<span style="color:#75715e">// Set up symbolic memory and prepare execution.
</span><span style="color:#75715e"></span>	S <span style="color:#f92672">=</span> [m <span style="color:#960050;background-color:#1e0010">→</span> m <span style="color:#f92672">|</span> m <span style="color:#960050;background-color:#1e0010">∈</span> M0].
	
	<span style="color:#75715e">// Initial program counter in P.
</span><span style="color:#75715e"></span>	l <span style="color:#f92672">=</span> l0
		
	<span style="color:#75715e">// Number of conditionals executed.
</span><span style="color:#75715e"></span>	k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> 
	
	<span style="color:#75715e">// Now invoke P intertwined with symbolic calculations.
</span><span style="color:#75715e"></span>	s <span style="color:#f92672">=</span> statement_at(l, M)
	
	<span style="color:#75715e">// Loop till an abort or a halt is encountered.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (s <span style="color:#960050;background-color:#1e0010">∈</span> { <span style="color:#f92672">/</span> abort, halt}) <span style="color:#66d9ef">do</span>
	
		<span style="color:#75715e">// Match the case of a program statement.
</span><span style="color:#75715e"></span>		match (s)
		
			<span style="color:#75715e">// Assignment statement.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">case</span> (m <span style="color:#960050;background-color:#1e0010">←</span> e)<span style="color:#f92672">:</span>
			
				<span style="color:#75715e">// Memory location for m is updated.
</span><span style="color:#75715e"></span>				S <span style="color:#f92672">=</span> S <span style="color:#f92672">+</span> [m <span style="color:#960050;background-color:#1e0010">→</span> evaluate_symbolic(e, M, S)]
				
				<span style="color:#75715e">// Evaluates expression e concretely.
</span><span style="color:#75715e"></span>				v <span style="color:#f92672">=</span> evaluate_concrete(e, M)
				
				<span style="color:#75715e">// Update the memory location as well.
</span><span style="color:#75715e"></span>				M <span style="color:#f92672">=</span> M <span style="color:#f92672">+</span> [m <span style="color:#960050;background-color:#1e0010">→</span> v]
				
				<span style="color:#75715e">// Increment the program counter after executing current statement.
</span><span style="color:#75715e"></span>				l <span style="color:#f92672">=</span> l0 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
			
			<span style="color:#75715e">// Conditional statement.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">case</span> (<span style="color:#66d9ef">if</span> (e) then <span style="color:#66d9ef">goto</span> l<span style="color:#960050;background-color:#1e0010">&#39;</span>)<span style="color:#f92672">:</span>
			
				<span style="color:#75715e">// Evalaute e concretely.
</span><span style="color:#75715e"></span>				b <span style="color:#f92672">=</span> evaluate_concrete(e, M)
				
				<span style="color:#75715e">// Evaluate e symbolically.
</span><span style="color:#75715e"></span>				c <span style="color:#f92672">=</span> evaluate_symbolic(e, M, S)
				
				
				<span style="color:#75715e">// Already have a path constraint.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> b then
				
					<span style="color:#75715e">// c has been added to the path constraint via bitwise AND.
</span><span style="color:#75715e"></span>					path_constraint <span style="color:#f92672">=</span> path_constraint <span style="color:#f92672">^</span> <span style="color:#f92672">&lt;</span>c<span style="color:#f92672">&gt;</span>
					
					<span style="color:#75715e">// Push the current state to stack.
</span><span style="color:#75715e"></span>					stack <span style="color:#f92672">=</span> compare_and_update_stack(<span style="color:#ae81ff">1</span>, k,stack)
					
					<span style="color:#75715e">// Jump to label.
</span><span style="color:#75715e"></span>					l <span style="color:#f92672">=</span> l<span style="color:#960050;background-color:#1e0010">&#39;</span>
				
				<span style="color:#66d9ef">else</span>
					<span style="color:#75715e">// c&#39;s negation has been added to the path constraint via bitwise AND.
</span><span style="color:#75715e"></span>					path constraint <span style="color:#f92672">=</span> path_constraint <span style="color:#f92672">^</span> <span style="color:#f92672">&lt;-</span>(c)<span style="color:#f92672">&gt;</span>
					
					<span style="color:#75715e">// Push the current state to stack.
</span><span style="color:#75715e"></span>					stack <span style="color:#f92672">=</span> compare_and_update_stack(<span style="color:#ae81ff">0</span>, k,stack)
					
					<span style="color:#75715e">// Increment the program counter after executing current statement.
</span><span style="color:#75715e"></span>					l <span style="color:#f92672">=</span> l0 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
					
				<span style="color:#75715e">// Keep track of conditionals.
</span><span style="color:#75715e"></span>				k <span style="color:#f92672">=</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
				
		s <span style="color:#f92672">=</span> statement_at(l, M)
	
	<span style="color:#75715e">// If an abort is encountered in the execution, raise exception.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (s <span style="color:#f92672">==</span> abort) then
		raise an exception
		
	<span style="color:#75715e">// If a halt is encountered, it&#39;ll solve path constraints.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span>
		<span style="color:#66d9ef">return</span> solve_path_constraint(k, path_constraint, stack)			
</code></pre></div><p><code>compare_and_update_stack(branch, k, stack)</code> is just a generic stack operation function used to check whether the current execution path matches the one predicted at the end of the previous execution and represented in <em>stack</em> passed between runs. If the prediction fails, <strong>forcing_ok</strong> flag is set to 0 and the instrumentation is restarted with a fresh random input vector.</p>
<p><code>statement_at(l, M)</code> fetches the next instruction to be executed in the context of <em>M</em>.</p>
<p>Any third party constraint solver can be employed for the task. An abstraction of the working of a suitable constraint solver is as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">solve_path_constraint(ktry, path_constraint, stack) <span style="color:#f92672">=</span>

	<span style="color:#75715e">// Take latest path constraint from the stack.
</span><span style="color:#75715e"></span>	let j be the smallest number such that
		<span style="color:#66d9ef">for</span> all h with <span style="color:#960050;background-color:#1e0010">−</span><span style="color:#ae81ff">1</span> <span style="color:#960050;background-color:#1e0010">≤</span> j<span style="color:#f92672">&lt;</span>h<span style="color:#f92672">&lt;</span>ktry, stack[h].done <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
		
	<span style="color:#75715e">// If none is found, directed search is finished.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> j <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">−</span><span style="color:#ae81ff">1</span> then
		<span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">0</span>, , )
	<span style="color:#66d9ef">else</span>
	
		<span style="color:#75715e">// Negate the path constraint found at the top of the stack.
</span><span style="color:#75715e"></span>		path_constraint[j] <span style="color:#f92672">=</span> neg(path_constraint[j])
		
		<span style="color:#75715e">// Add it to the branch.
</span><span style="color:#75715e"></span>		stack[j].branch<span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">¬</span>stack[j].branch
		
		<span style="color:#75715e">// Call that branch to explore it.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (path constraint[<span style="color:#ae81ff">0</span>,... ,j] has a solution I) then
			<span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">1</span>,stack[<span style="color:#ae81ff">0.</span>.j], I
		<span style="color:#66d9ef">else</span>
			solve_path_constraint(j, path_constraint, stack)
</code></pre></div><h2 id="sage">SAGE</h2>
<p>Following the success of DART, a new framework known as <strong>SAGE</strong>(<strong>Scalable, Automated, Guided Execution</strong>) was born in 2008 that employs DART in the background, to perform fuzzing on large applications (mainly file-reading applications) by using symbolic execution of the target programs at the x86 binary level. It&rsquo;s an extremely versatile tool since it is machine-code based, hence can run binaries programmed using various programming languages.</p>
<blockquote>
<p>We present an alternative whitebox fuzz testing approach inspired by recent advances in symbolic execution and dynamic test generation. Our approach records an actual run of the program under test on a well-formed input, symbolically evaluates the recorded trace, and gathers constraints on inputs capturing how the program uses these. The collected constraints are then negated one by one and solved with a constraint solver, producing new inputs that exercise different control paths in the program. This process is repeated with the help of a code-coverage maximizing heuristic designed to find defects as fast as possible.</p>
</blockquote>
<p>A <strong>Generation Search Algorithm</strong> can described as follows:</p>
<ul>
<li>Systematically explores execution of large applications with large input and deep paths.</li>
<li>Employs heuristics to maximize code coverage quickly, which would lead to finding bugs faster.</li>
<li>Resilient to divergences. Whenever it occurs, search is able to recover and continue.</li>
</ul>
<p>SAGE basically performs a generational search repeating the following tasks:</p>
<ol>
<li><strong>Tester</strong>: harness functionality executing the program with random inputs.</li>
<li><strong>Tracer</strong>: records logs of execution of the target binary.</li>
<li><strong>CoverageCollector</strong>:  computes the statistics on basic blocks which were executed during the run by going through the recorded execution.</li>
<li><strong>SymbolicExecution</strong>: replays the recorded execution to collect input related constraints and generate new inputs using a constraint solver.</li>
</ol>
<p><img src="https://hexterisk.github.io/blog/DART_&amp;_SAGE/slide16-l.jpg" alt="">
<em>Tasks running in order.</em></p>
<p>These tasks are optimized to handle large execution traces with features like constraint caching, common subexpression elimination and prevention of endless loop expansions.</p>
<p>Citation: <a href="http://www.cs.toronto.edu/~geri/doc/GeriGrolingerCSC2125Report.pdf">DART</a>, <a href="http://osl.cs.illinois.edu/docs/pldi05/dart.pdf">DART: Directed Automated Random Testing</a>, <a href="https://www.cse.iitd.ac.in/~siy117527/sil765/readings/fuzzing%20testing.pdf">From Blackbox Fuzzing to Whitebox Fuzzing towards Verification</a>, <a href="https://patricegodefroid.github.io/public_psfiles/ndss2008.pdf">Automated Whitebox Fuzz Testing</a>, <a href="https://pdfs.semanticscholar.org/67ca/f3b9d76a8bf9e2c5420344640763626f7af1.pdf">Automated Whitebox Fuzz Testing PPT</a>.</p>

        </div>
    </article>

    <hr />

    <div class="post-info">
        <p>
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                class="feather feather-tag meta-icon">
                <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                <line x1="7" y1="7" x2="7" y2="7"></line>
            </svg><span class="tag"><a href="https://hexterisk.github.io/blog/%20tags/fuzzing">fuzzing</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/%20tags/microsoft">microsoft</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/%20tags/whitebox">whitebox</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/%20tags/greybox">greybox</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/%20tags/sage">sage</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/%20tags/dart">dart</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/%20tags/automated">automated</a></span><span class="tag"><a href="https://hexterisk.github.io/blog/%20tags/symbolic">symbolic</a></span>
        </p>

        <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                class="feather feather-file-text">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>2524 Words</p>

        <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                class="feather feather-calendar">
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="16" y1="2" x2="16" y2="6"></line>
                <line x1="8" y1="2" x2="8" y2="6"></line>
                <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>2020-09-25 05:30 &#43;0530</p>
    </div>

    
    <div class="pagination">
        <div class="pagination__title">
            <span class="pagination__title-h"></span>
            <hr />
        </div>

        <div class="pagination__buttons">

            
            <span class="button previous">
                <a href="https://hexterisk.github.io/blog/posts/2020/09/16/sanitation/">
                    <span class="button__text">Sanitation</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            

            

        </div>
    </div>
    

    
</main>

            </div>

            
                <footer class="footer">
    
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">rhazdon</a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content" style="margin-bottom: -0.8rem;">
            <span><a style="text-decoration: none;"> .</a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span><a style="text-decoration: none;" style="font-size: 1.4rem; margin-bottom: -1.0rem;">..:</a></span>
        </div>
    </div>
</footer>
            
        </div>

        




<script type="text/javascript" src="https://hexterisk.github.io/blog/bundle.min.08ccaf9cef8b4e0ebd0b0158e66a7bfc0ddbb2194cdb0099e8814ddb89cc7628b27b1158846564e6e03d9ffc5f4d1bc7dfc274d359f9408d1c63d73a3f7332e9.js" integrity="sha512-CMyvnO&#43;LTg69CwFY5mp7/A3bshlM2wCZ6IFN24nMdiiyexFYhGVk5uA9n/xfTRvH38J001n5QI0cY9c6P3My6Q=="></script>



    </body>
</html>
