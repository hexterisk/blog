<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pwn the world.</title>
    <link>https://hexterisk.github.io/blog/</link>
    <description>Recent content on Pwn the world.</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Wed, 21 Apr 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hexterisk.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Concurrency Patterns</title>
      <link>https://hexterisk.github.io/blog/posts/2021/10/01/concurrency-patterns/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/10/01/concurrency-patterns/</guid>
      <description>Concurrency Design Patterns describe ways of dealing with concurrent executing code, be it multi-threaded or multi-processed.
Active Object  Decouple method execution from method invocation for objects that each live in their own thread of control. The goal is to introduce concurrency, by using asynchronous method invocation and a scheduler for handling requests.
 The Active Object pattern introduces the following components:
 Proxy  The interface of the object to which a client connects to.</description>
    </item>
    
    <item>
      <title>Structural Patterns</title>
      <link>https://hexterisk.github.io/blog/posts/2021/09/10/structural-patterns/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/09/10/structural-patterns/</guid>
      <description>Structural Design Patterns help in composing small structures into larger structures, while ensuring that these larger structures remain flexible and efficient. These larger structures remain simplified through the realization of the relationship between it&amp;rsquo;s smaller component structures, that is, how each component inherits from each other.
Structural Class Patterns  Composes interfaces and implementations through (multiple) inheritance. Useful to make independently developed classes work together.  Structural Object Patterns  Realizes new functionality through composition of different objects.</description>
    </item>
    
    <item>
      <title>Behavioral Patterns</title>
      <link>https://hexterisk.github.io/blog/posts/2021/08/16/behavioral-patterns/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/08/16/behavioral-patterns/</guid>
      <description>Behavioral Design Patterns are concerned with optimizing the complex flow of control and communication between objects during run-time. Their main goal is to assign responsibilities between objects in a manner that ensures loose coupling.
Behavioral Class Patterns Inheritance is employed to distribute behavior between classes.
Behavioral Object Patterns Composition is employed to characterize how a group of objects work with each other to perform a task that cannot be accomplished by a single object.</description>
    </item>
    
    <item>
      <title>Creational Patterns</title>
      <link>https://hexterisk.github.io/blog/posts/2021/07/02/creational-patterns/</link>
      <pubDate>Fri, 02 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/07/02/creational-patterns/</guid>
      <description>Creational Design Patterns reduce the complexity in creation of different objects of shared type/properties.
These patterns simplify object creation mechanisms by separating the workings of an object&amp;rsquo;s creation, composition and representation. This in turn results in increased flexibility. Instead of hardcoding data into classes for creating objects every time, we can employ these patterns for the instantiation of an object dependent on the situation. This ensures that the set of related objects share a common ancestor for common properties.</description>
    </item>
    
    <item>
      <title>Reuse</title>
      <link>https://hexterisk.github.io/blog/posts/2021/05/21/reuse/</link>
      <pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/05/21/reuse/</guid>
      <description>While designing a class, always keep the Open-Closed Principle in mind. It states that,
 software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
 This implies that an entity shall allow extensions to itself, but no modification to its source code. We are therefore allowed to extend our base class, and consequently implement re-usability.
Class Inheritance Inheritance models an Is-A relationship, where the child class inherits properties from the parent class, making the child class a specialized version of the parent class.</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://hexterisk.github.io/blog/posts/2021/04/28/overview/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/04/28/overview/</guid>
      <description>An general overview of the Design Patterns.
Classification Purpose Purpose reflects the use case of a design pattern.
Creational Pattern concerns the process of object creation.
Structural Pattern deals with the composition of classes or objects.
Behavioral Pattern characterizes the ways in which classes or objects interact and distribute responsibility.
Catalog of design patterns based on Purpose.
Scope The scope of a design patterns specifies where it is primarily applied.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://hexterisk.github.io/blog/posts/2021/04/10/introduction/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/04/10/introduction/</guid>
      <description>A design pattern is a code structure used to solve commonly occurring problems in software development. It is a generic description of different components&amp;rsquo; design, their relationships, and how they come together to solve the said problem in the specified context. It is characterized by:
 Pattern Name  To associate a certain solution to a name for ease of reference, through appropriate association.   Problem  The design problem and issues to be addressed in a specified context, to which the solution described by the design pattern is applicable.</description>
    </item>
    
    <item>
      <title>DART &amp; SAGE</title>
      <link>https://hexterisk.github.io/blog/posts/2021/03/15/dart-sage/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/03/15/dart-sage/</guid>
      <description>DART Back in 2005, researchers at Microsoft came up with a concolic testing tool called DART(Directed Automated Random Testing). The tool can be used in the unit testing phase, as well as can be applied to large programs.
 We present a new tool, named DART, for automatically testing software that combines three main techniques: (1) automated extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs random testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test inputs to direct systematically the execution along alternative program paths.</description>
    </item>
    
    <item>
      <title>Sanitation</title>
      <link>https://hexterisk.github.io/blog/posts/2021/02/12/sanitation/</link>
      <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/02/12/sanitation/</guid>
      <description>Sanitation tools, or sanitizers, are a set of libraries that can directly observe and flag an incorrect behavior for a certain class of violation at runtime.
Sanitizers are employed by instrumenting the source code. The compiled binary, therefore, essentially has certain tripwires that catch any invalid or incorrect behavior and reports it. The fact that it only brings about minimal performance overhead allows it to be coupled with fuzzing techniques, a powerful combination.</description>
    </item>
    
    <item>
      <title>Architecture</title>
      <link>https://hexterisk.github.io/blog/posts/2021/01/20/architecture/</link>
      <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.github.io/blog/posts/2021/01/20/architecture/</guid>
      <description>A robust pipeline needs to be established to ensure that a fuzzer is effective and efficient. The pipeline is required to perform the following tasks:
 Generate new test cases. Ensure delivery of the test cases to, and safe execution, of the target. Record the statistics from the execution of the test cases. Reproduce the crashes. Triage the crashes.  Generic fuzzing pipeline.
Separate modules perform different set of the aforementioned tasks.</description>
    </item>
    
  </channel>
</rss>