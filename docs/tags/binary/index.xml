<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>binary on Pwn the world.</title>
    <link>https://hexterisk.tech/blog/tags/binary/</link>
    <description>Recent content in binary on Pwn the world.</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 09 May 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hexterisk.tech/blog/tags/binary/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Serial 2</title>
      <link>https://hexterisk.tech/blog/posts/2020/05/09/serial-2/</link>
      <pubDate>Sat, 09 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/05/09/serial-2/</guid>
      <description>Name: serial: 2 Date release: 27 Sep 2019 Author: sk4 Series: serial  Initial Discovery VMIP is the VM‚Äôs IP Address
LHIP is the Local Host‚Äôs IP Address
Compare the commands I ran, and the formats specified to check where you need to replace values according to your machine.
IP Discovery Run sudo netdiscover.
It detects online hosts by sending ARP requests.
Output of netdiscover.
192.168.1.10 happens to be the IP of the VM.</description>
    </item>
    
    <item>
      <title>Constraint Solvers and Z3</title>
      <link>https://hexterisk.tech/blog/posts/2020/01/09/constraint-solvers-and-z3/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/01/09/constraint-solvers-and-z3/</guid>
      <description>A constraint solver must be versatile, that is, it should be able to act as an:
 Interpreter: Given the input, solve for the output of the equation. Inverter: Given the output, solve for the input of the equation. Synthesizer: Act as both Interpreter and Inverter.  Formulating Programs Assume a formula ùëÜ‚Çö(ùë•, ùë¶) which holds if and only if program P(x) outputs value y such that
Program: f(ùë•) { return ùë• + ùë• }</description>
    </item>
    
    <item>
      <title>Principles of Symbolic Execution</title>
      <link>https://hexterisk.tech/blog/posts/2020/01/09/principles-of-symbolic-execution/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/01/09/principles-of-symbolic-execution/</guid>
      <description>Symbolic Execution, or symbex, is a software analysis technique that expresses program state in terms of logical formulas that you can automatically reason about to answer complex questions about a program‚Äôs behavior. Can automatically increase the code coverage of dynamic analyses by generating new inputs that lead to unexplored program paths. Apply it sparingly and carefully because of scalability issues.
 Symbex executes (or emulates) an application with symbolic values.  Symbolic values represent a domain covering possible concrete values, represented by symbols like œÜ.</description>
    </item>
    
    <item>
      <title>Stack and it&#39;s Frames</title>
      <link>https://hexterisk.tech/blog/posts/2020/01/09/stack-and-its-frames/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/01/09/stack-and-its-frames/</guid>
      <description>Stack is a data structure, and means exactly what it&amp;rsquo;s name says - a stack(of objects). It is mainly characterized by pushing and popping operations. You push items onto the stack, and then pop those items off. A stack is therefore a LIFO(last in, first out) structure.¬†Memory for functions, local variables, and flow control is stored in the stack.
Stack Layout The stack grows from higher addresses to lower addresses.</description>
    </item>
    
    <item>
      <title>Symbolic Execution and Angr</title>
      <link>https://hexterisk.tech/blog/posts/2020/01/09/symbolic-execution-and-angr/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/01/09/symbolic-execution-and-angr/</guid>
      <description>Symbolic Execution is mainly focused on converting a program made up of a concrete set of instructions into an equation-like format. This is achieved with two core components:
Symbols Different values in a program(such as the user input) are substituted with Symbols(variables or placeholders). These symbols pertain to a domain full of values, allowing us to explore the program in a much more open form, basically ‚Äúwalking through the program‚Äù with a domain full of values(handled by any one of the constraint solving backends like Z3) instead of walking a fixed path due to a fixed hard-coded value/input.</description>
    </item>
    
    <item>
      <title>Dynamic Taint Analysis</title>
      <link>https://hexterisk.tech/blog/posts/2020/01/08/dynamic-taint-analysis/</link>
      <pubDate>Wed, 08 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/01/08/dynamic-taint-analysis/</guid>
      <description>DTA (Dynamic Taint Analysis), also called DFT (Data Flow Tracking), Taint Tracking, or simply Taint Analysis, is a program analysis technique that allows you to determine the influence that a selected program state has on other parts of the program state. Taint any data that a program receives from the network, track that data, and raise an alert if it affects the program counter.
 Indicate a control-flow hijacking attack. Implemented on top of a dynamic binary instrumentation platform.</description>
    </item>
    
    <item>
      <title>Binary Instrumentation</title>
      <link>https://hexterisk.tech/blog/posts/2020/01/07/binary-instrumentation/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/01/07/binary-instrumentation/</guid>
      <description>Inserting new code at any point in an existing binary to observe or modify the binary‚Äôs behavior in some way is called instrumenting the binary. The point where you add new code is called the instrumentation point, and the added code is called instrumentation code.
Tradeoffs of Dynamic and Static Binary Instrumentation.
Static Binary Instrumentation Static Binary Instrumentation works by disassembling a binary and then adding instrumentation code where needed and storing the updated binary permanently on disk.</description>
    </item>
    
    <item>
      <title>Binary Obfuscation</title>
      <link>https://hexterisk.tech/blog/posts/2020/01/07/binary-obfuscation/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/01/07/binary-obfuscation/</guid>
      <description>The main aim of Binary Obfuscation is to hinder the process of static analysis of a binary.¬†Renaming the symbols(variables and functions) of a binary implies that the clues as to what data a variable holds or what task a function performs that could be obtained from their names, are lost. This makes it a little harder for the analysts to keep a track of all the symbols without documenting them.</description>
    </item>
    
    <item>
      <title>Simple Code Injection Techniques for ELF</title>
      <link>https://hexterisk.tech/blog/posts/2020/01/06/simple-code-injection-techniques-for-elf/</link>
      <pubDate>Mon, 06 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/01/06/simple-code-injection-techniques-for-elf/</guid>
      <description>Bare-Metal Binary Modification  Modify an existing binary is by directly editing the bytes of a binary file in hexadecimal format, using a program like hexedit.  Use a disassembler to identify the code or data bytes to be changed and then use a hex editor to make the changes. Advantage: Simple and requires only basic tools. Any padding bytes, dead code (such as unused functions), or unused data, can be overwritten with something new.</description>
    </item>
    
    <item>
      <title>Disassembly and Binary Analysis Fundamentals</title>
      <link>https://hexterisk.tech/blog/posts/2020/01/05/disassembly-and-binary-analysis-fundamentals/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexterisk.tech/blog/posts/2020/01/05/disassembly-and-binary-analysis-fundamentals/</guid>
      <description>##Static Disassembly
When people say disassembly, they usually mean static disassembly, which involves extracting the instructions from a binary without executing it.
Linear Disassembly Disassembly desynchronization due to inline data interpreted as code. The instruction where the disassembly resynchronizes is shaded gray.
 It iterates through all code segments in a binary, decoding all bytes consecutively and parsing them into a list of instructions. Many simple disassemblers, including objdump, use this approach.</description>
    </item>
    
  </channel>
</rss>